<!-- This file is auto-generated by bin/generate_style_guide.ml -->
<!-- Do not edit manually. Edit lib/guide.ml instead. -->

# OCaml Coding Style Guide

This document outlines the coding and testing conventions for this project. The goal is to ensure the codebase is clear, robust, and maintainable. The style is inspired by the best practices of the modern OCaml ecosystem, emphasizing modularity and pragmatism.

## Core Philosophy

1. **Interface-First Design**: Always start by designing the module's interface in the `.mli` file. A clean interface is more critical than a clever implementation.

2. **Modularity**: Build small, focused modules that do one thing well. Compose them to build larger systems.

3. **Simplicity and Clarity (KISS)**: Prioritize clarity over conciseness. Strive for the simplest possible solution and avoid overly clever or obscure constructs.

4. **Explicitness**: Make control flow and error handling explicit. Avoid exceptions for recoverable errors.

5. **Purity and Side-Effect Management**: Prefer pure functions. Isolate side-effects (I/O, state mutation) at the edges of the application. This is a fundamental principle for building maintainable, testable, and composable systems.

6. **Be Deliberate with Dependencies**: Every dependency has a cost - maintenance burden, increased compile times, and expanded API surface. Before adding a new dependency, consider if the functionality can be achieved with existing tools or a small amount of code. When you do add dependencies, choose high-quality, well-maintained libraries.

7. **NEVER USE Obj.magic**: The `Obj` module is not part of the OCaml language and breaks type safety. There is always a better, type-safe solution.

### [E100] No Obj.magic

Obj.magic completely bypasses OCaml's type system and is extremely dangerous. It can lead to segmentation faults, data corruption, and unpredictable behavior. Instead, use proper type definitions, GADTs, or polymorphic variants. If you absolutely must use unsafe features, document why and isolate the usage.

**Examples:**

**Bad:**
```ocaml
let coerce x = Stdlib.Obj.magic x
```

**Good:**
```ocaml
(* Use proper type conversions *)
let int_of_string_opt s =
  try Some (int_of_string s) with _ -> None

(* Or use variant types *)
type value = Int of int | String of string
let to_int = function Int i -> Some i | _ -> None
```


## Dependencies and Tooling

**Build System**: The project is built exclusively with `dune`.

**Formatting**: All code is formatted automatically with `ocamlformat`. Run `dune fmt` before committing. Ensure you have a `.ocamlformat` file in your project root.

### [E500] Missing OCamlformat File

All OCaml projects should have a .ocamlformat file in the root directory to ensure consistent code formatting. Create one with your preferred settings.

**Core Libraries**: Projects typically embrace a curated set of high-quality libraries for common tasks. For example:

- **Concurrency**: `eio`

- **Regular Expressions**: `re` (instead of Str module)

- **Structured Output**: `fmt` (instead of Printf/Format)

- **Logging**: `logs`

- **CLI Parsing**: `cmdliner`

- **JSON Handling**: `yojson`

- **HTTP**: `cohttp-eio`

- **Test Framework**: `Alcotest`

### [E200] Outdated Str Module

The Str module is outdated and has a problematic API. Use the Re module instead for regular expressions. Re provides a better API, is more performant, and doesn't have global state issues.

**Examples:**

**Bad:**
```ocaml
let contains_at s =
  Str.string_match (Str.regexp ".*@.*") s 0

```

**Good:**
```ocaml
(* Requires: opam install re *)
let at_re = Re.compile (Re.str "@")
let contains_at s = Re.execp at_re s
```


### [E205] Consider Using Fmt Module

The Fmt module provides a more modern and composable approach to formatting. It offers better type safety and cleaner APIs compared to Printf/Format modules.

**Examples:**

**Bad:**
```ocaml
let make_error msg line = 
  Stdlib.Printf.sprintf "Error: %s at line %d" msg line
let print_count n = 
  Stdlib.Printf.printf "Processing %d items...\n" n
```

**Good:**
```ocaml
(* Requires: opam install fmt *)
let make_error msg line = 
  Fmt.str "Error: %s at line %d" msg line
let print_count n = 
  Fmt.pr "Processing %d items...@." n
```


## Module and Interface Design

**Documentation**: Every `.mli` file must begin with a top-level documentation comment explaining its purpose. Focus on *what* the module provides, not *how* it is implemented.

### [E405] Missing Value Documentation

All public values should have documentation explaining their purpose and usage. Add doc comments (** ... *) before or after value declarations in .mli files.

**Examples:**

**Bad:**
```ocaml
type t
val parse : string -> t

(** Documentation after is also acceptable *)
val format : t -> string

val missing_documentation : int -> int
```

**Good:**
```ocaml
type t

(** [parse str] converts a string to type [t].
    @raise Invalid_argument if [str] is malformed. *)
val parse : string -> t

val format : t -> string
(** [format t] converts a value of type [t] to a string representation. *)

(** [process n] processes an integer value. *)
val process : int -> int
```


**Interface (`.mli`) Style**: Document every exported value. Use a consistent, concise style.

### [E410] Bad Documentation Style

Follow OCaml documentation conventions: Functions should use '[name args] description.' format. All documentation should end with a period. Avoid redundant phrases like 'This function...'.

**Examples:**

**Good:**
```ocaml
val is_bot : t -> bool
(** [is_bot u] is [true] if [u] is a bot user. *)
```

**Good:**
```ocaml
type id = string
(** A user identifier. *)
```


**Documentation Philosophy**: For functions, use the `[function_name arg1 arg2] is ...` pattern.

For values, describe what the value represents.

**Abstract Types**: Keep types abstract (`type t`) whenever possible. Expose smart constructors and accessors instead of record fields to maintain invariants.

**Standard Interfaces for Data Types**: For modules defining a central data type `t`, consider providing the following functions where applicable:

- `val v : ... -> t`: A pure, smart constructor for creating values of type `t` in memory. This function should not perform any I/O.

- `val create : ... -> (t, Error.t) result`: A function that performs a side-effect, like an API call, to create a resource.

- `val pp : t Fmt.t`: A pretty-printer for logging and debugging.

- `val equal : t -> t -> bool`: A structural equality function.

- `val compare : t -> t -> int`: A comparison function for sorting.

- `val of_json : Yojson.Safe.t -> (t, string) result`: For parsing from JSON.

- `val to_json : t -> Yojson.Safe.t`: For serializing to JSON.

- `val validate : t -> (t, string) result`: For validating the integrity of the data.

### [E415] Missing Standard Functions

The main type 't' should implement standard functions: equal, compare, and pp (pretty-printer) for better usability and consistency across the codebase. For simple types, polymorphic equal (=) and compare functions are sufficient. For more complex types with invariants or custom representations, implement specialized versions.

**Examples:**

**Bad:**
```ocaml
type t = { id: int; name: string }
```

**Good:**
```ocaml
type t = { id: int; name: string }
val equal : t -> t -> bool
val compare : t -> t -> int
val pp : Format.formatter -> t -> unit
```


## Project Structure

**Interface Files**: Create `.mli` files for all public modules to define clear interfaces and hide implementation details.

### [E505] Missing MLI File

Library modules should have corresponding .mli files for proper encapsulation and API documentation. Create interface files to hide implementation details and provide a clean API.

**Examples:**

**Bad:**
```ocaml
type t = { name: string; id: int }
let create name id = { name; id }
let name t = t.name
```

**Good:**
```ocaml
(* user.mli *)
type t
val create : string -> int -> t
val name : t -> string
```


## Command-Line Applications

For command-line applications in the `bin/` directory, it's common to use a library like `Cmdliner`.

**Shared Functionality**: Common functionality, such as authentication and logging setup, can be placed in a shared module (e.g., `bin/common.ml`).

**`run` function**: A shared module might provide a `run` function that initializes the application's main loop and environment (e.g., an Eio loop). This should be used by all commands to ensure a consistent environment.

## Error Handling

We use the `result` type for all recoverable errors. Exceptions are reserved for programming errors (e.g., `Invalid_argument`).

**Central Error Type**: Define a single, comprehensive error type for the library (e.g., in `lib/error.ml`).

```ocaml
(* In lib/error.mli *)
type t = [
  | `Api of string * Yojson.Safe.t (* code, fields *)
  | `Json_parse of string
  | `Network of string
  | `Msg of string
]

val pp : t Fmt.t
```

**Error Helpers**: In implementation files, use helper functions to construct errors. This ensures consistency.

```ocaml
(* In an implementation file *)
let err_api code fields = Error (`Api (code, fields))
let err_parse msg = Error (`Json_parse msg)

let find_user_id json =
  match Yojson.Safe.Util.find_opt "id" json with
  | Some (`String id) -> Ok id
  | Some _ -> err_parse "Expected string for user ID"
  | None -> err_parse "Missing user ID"
```

**No Broad Exceptions**: Never use `try ... with _ -> ...`. Always match on specific exceptions.

### [E105] Catch-all Exception Handler

Catch-all exception handlers (with _ ->) can hide unexpected errors and make debugging difficult. Always handle specific exceptions explicitly. If you must catch all exceptions, log them or re-raise after cleanup.

**Examples:**

**Bad:**
```ocaml
let parse_int s =
  try int_of_string s with _ -> 0

let read_config () =
  try 
    let ic = open_in "config.txt" in
    let data = input_line ic in
    close_in ic;
    data
  with _ -> "default"
```

**Good:**
```ocaml
let parse_int s =
  try int_of_string s with
  | Failure _ -> 0

let read_config () =
  try 
    let ic = open_in "config.txt" in
    let data = input_line ic in
    close_in ic;
    data
  with
  | Sys_error msg -> 
      Fmt.epr "Config error: %s@." msg;
      "default"
  | End_of_file -> 
      Fmt.epr "Config file is empty@.";
      "default"
```

**Good:**
```ocaml
module Log = struct
  let err f = f Format.err_formatter
end

let dangerous_operation () =
  failwith "Something went wrong"

let safe_wrapper () =
  try dangerous_operation () with
  | exn ->
      Log.err (fun m -> 
        Format.fprintf m "Operation failed: %s@." 
          (Printexc.to_string exn));
      raise exn
```


**No Silenced Warnings**: Fix underlying issues instead of silencing compiler warnings with attributes like `[@warning "-nn"]`.

### [E110] Silenced Warning

Warnings should be addressed rather than silenced. Fix the underlying issue instead of using warning suppression attributes. If you must suppress a warning, document why it's necessary.

**Examples:**

**Bad:**
```ocaml
[@@@ocaml.warning "-32"]
let unused_function x = x + 1

[@@ocaml.warning "-27"]
let partial_match = function
  | Some x -> x

[@ocaml.warning "-9"]
type t = { mutable field : int; another : string }
```

**Good:**
```ocaml
let used_function x = x + 1

let () = print_int (used_function 5)

let complete_match = function
  | Some x -> x
  | None -> 0

type t = { field : int; another : string }
```


**Initialization Failures**: For unrecoverable errors during startup (e.g., missing configuration), it is acceptable to fail fast using `Fmt.failwith`.

```ocaml
let tls_config =
  match Tls.Config.client ~authenticator () with
  | Ok config -> config
  | Error (`Msg msg) -> Fmt.failwith "Failed to create TLS config: %s" msg
```

## Naming and Formatting

**File Naming**: Lowercase with underscores (e.g., `user_profile.ml`).

### [E305] Module Naming Convention

Module names should use Snake_case (e.g., My_module, User_profile). File names use lowercase_with_underscores which OCaml automatically converts to module names.

**Examples:**

**Bad:**
```ocaml
module UserProfile = struct end
```

**Good:**
```ocaml
module User_profile = struct end
```


### [E300] Variant Naming Convention

Variant constructors should use Snake_case (e.g., Waiting_for_input, Processing_data), not CamelCase. This matches the project's naming conventions.

**Examples:**

**Bad:**
```ocaml
type status = 
  | WaitingForInput
  | ProcessingData
  | ErrorOccurred
```

**Good:**
```ocaml
type status = 
  | Waiting_for_input  (* Snake_case *)
  | Processing_data
  | Error_occurred
```


### [E315] Type Naming Convention

Type names should use snake_case. The primary type in a module should be named t, and identifiers should be id. This convention helps maintain consistency across the codebase.

**Examples:**

**Bad:**
```ocaml
type userProfile = { name : string }
type http_response = HttpOk | HttpError
```

**Good:**
```ocaml
type user_profile = { name: string }
type http_response = Ok | Error
```


### [E310] Value Naming Convention

Values and function names should use snake_case (e.g., find_user, create_channel). Short, descriptive, and lowercase with underscores. This is the standard convention in OCaml for values and functions.

**Examples:**

**Bad:**
```ocaml
type user = { name : string }
let myValue = 42
let getUserName user = user.name
```

**Good:**
```ocaml
type user = { name : string }
let my_value = 42
let get_user_name user = user.name
```


### [E320] Long Identifier Names

Avoid using too many underscores in identifier names as they make code harder to read. Consider using more descriptive names or restructuring the code to avoid deeply nested concepts.

**Examples:**

**Bad:**
```ocaml
let get_user_profile_data_from_database_by_id () = 42
```

**Good:**
```ocaml
let get_user_by_id () = 42
```


### [E325] Function Naming Convention

Functions that return option types should be prefixed with 'find_', while functions that return non-option types should be prefixed with 'get_'. This convention helps communicate the function's behavior to callers.

**Examples:**

**Bad:**
```ocaml
let get_user () = None  (* returns option but named get_* *)
let find_name () = "John"  (* returns string but named find_* *)
```

**Good:**
```ocaml
let find_user () = None  (* returns option, correctly named *)
let get_name () = "John"  (* returns string, correctly named *)
```


**Labels**: Use labels only when they clarify the meaning of an argument, not for all arguments. Avoid `~f` and `~x`.

**Formatting**: Trust `ocamlformat`. No manual formatting.

## API Design

**Avoid Boolean Blindness**: Never use multiple boolean arguments in a function - they make call sites ambiguous and error-prone. Instead, use explicit variant types that leverage OCaml's type system for clarity.

### [E350] Boolean Blindness

Functions with multiple boolean parameters are hard to use correctly. It's easy to mix up the order of arguments at call sites. Consider using variant types, labeled arguments, or a configuration record instead.

**Examples:**

**Bad:**
```ocaml
(* BAD - Boolean blindness *)
let create_widget visible bordered = ...
let w = create_widget true false  (* What does this mean? *)
```

**Good:**
```ocaml
(* GOOD - Explicit variants *)
type visibility = Visible | Hidden
type border = With_border | Without_border
let create_widget ~visibility ~border = ...
let w = create_widget ~visibility:Visible ~border:Without_border
```


**Use Phantom Types for Safety**: When appropriate, use phantom types to enforce invariants at compile time rather than runtime.

**Builder Pattern for Complex Configuration**: For functions with many optional parameters, consider using a builder pattern with a record type rather than many optional arguments.

## Function Design

**Keep Functions Small and Focused**: A function should do one thing well. Decompose complex logic into smaller, well-defined helper functions. This improves readability, testability, and reusability. Aim for functions under 50 lines. As a rule of thumb, avoid deep nesting of `match` or `if` statements; more than two or three levels is a strong signal that the function should be refactored.

### [E005] Long Functions

This issue means your functions are too long and hard to read. Fix them by extracting logical sections into separate functions with descriptive names. Note: Functions with pattern matching get additional allowance (2 lines per case). Pure data structures (lists, records) are also exempt from length checks. For better readability, consider using helper functions for complex logic. Aim for functions under 50 lines of actual logic.

**Examples:**

**Bad:**
```ocaml
let process_all_data x y z =
  (* This function is intentionally long to demonstrate the rule *)
  let a = x + 1 in
  let b = y + 1 in
  let c = z + 1 in
  let d = a * 2 in
  let e = b * 2 in
  let f = c * 2 in
  let g = d + e in
  let h = e + f in
  let i = f + d in
  let j = g * 2 in
  let k = h * 2 in
  let l = i * 2 in
  let m = j + k in
  let n = k + l in
  let o = l + j in
  let p = m * 2 in
  let q = n * 2 in
  let r = o * 2 in
  let s = p + q in
  let t = q + r in
  let u = r + p in
  let v = s * 2 in
  let w = t * 2 in
  let x1 = u * 2 in
  let y1 = v + w in
  let z1 = w + x1 in
  let a1 = x1 + v in
  let b1 = y1 * 2 in
  let c1 = z1 * 2 in
  let d1 = a1 * 2 in
  let e1 = b1 + c1 in
  let f1 = c1 + d1 in
  let g1 = d1 + b1 in
  let h1 = e1 * 2 in
  let i1 = f1 * 2 in
  let j1 = g1 * 2 in
  let k1 = h1 + i1 in
  let l1 = i1 + j1 in
  let m1 = j1 + h1 in
  let n1 = k1 * 2 in
  let o1 = l1 * 2 in
  let p1 = m1 * 2 in
  let q1 = n1 + o1 in
  let r1 = o1 + p1 in
  let s1 = p1 + n1 in
  let t1 = q1 * 2 in
  let u1 = r1 * 2 in
  let v1 = s1 * 2 in
  let w1 = t1 + u1 in
  let x2 = u1 + v1 in
  let y2 = v1 + t1 in
  let result = w1 + x2 + y2 in
  result
```

**Good:**
```ocaml
let step1 x y = (x + 1, y + 1)
let step2 (a, b) = (a * 2, b * 2)
let combine (c, d) = (c + d) * 2

let process_all x y =
  let (a, b) = step1 x y in
  let (c, d) = step2 (a, b) in
  combine (c, d)
```


### [E010] Deep Nesting

This issue means your code has too many nested conditions making it hard to follow. Fix it by extracting nested logic into helper functions, using early returns to reduce nesting, or combining conditions when appropriate. Aim for maximum nesting depth of 4.

**Examples:**

**Bad:**
```ocaml
let process x y z =
  if x > 0 then
    if y > 0 then
      if z > 0 then
        if x < 100 then
          x + y + z
        else 0
      else 0
    else 0
  else 0
```

**Good:**
```ocaml
let process x y z =
  if x <= 0 || y <= 0 || z <= 0 then 0
  else if x >= 100 then 0
  else x + y + z
```


**Complexity Management**: Break down functions with high 
             cyclomatic complexity into smaller, focused helper functions with 
             clear names.

### [E001] High Cyclomatic Complexity

High cyclomatic complexity makes code harder to understand and test. Consider breaking complex functions into smaller, more focused functions. Each function should ideally do one thing well.

**Examples:**

**Bad:**
```ocaml
let check_input x y z =
  if x > 0 then
    if y > 0 then
      if z > 0 then
        if x + y > z then
          if y + z > x then
            if x + z > y then
              "valid"
            else "invalid"
          else "invalid"
        else "invalid"
      else "invalid"
    else "invalid"
  else "invalid"
```

**Good:**
```ocaml
let check_positive x = x > 0

let check_triangle x y z =
  x + y > z && y + z > x && x + z > y

let check_input x y z =
  if not (check_positive x && check_positive y && check_positive z) then
    "invalid"
  else if not (check_triangle x y z) then
    "invalid"
  else
    "valid"
```


**Composition over Abstraction**: Favor the composition of small, 
             concrete functions to build up complex behavior. Avoid deep 
             abstractions and complex class hierarchies.

**Data-Oriented Design**: Design functions to operate on simple, 
             immutable data structures (records, variants, etc.). Avoid 
             creating complex objects with hidden internal state.

**Avoid Premature Generalization**: Write code that solves the 
             problem at hand. Avoid adding unnecessary complexity or 
             generality that is not required by the current needs of the 
             project.

## Logging

Effective logging is crucial for debugging and monitoring. We use the `logs` library for all logging.

**Log Source**: Each module should define its own log source.

### [E510] Missing Log Source

Modules that use logging should declare a log source for better debugging and log filtering. Add 'let src = Logs.Src.create "module.name" ~doc:"..."'

**Examples:**

**Good:**
```ocaml
let log_src = Logs.Src.create "project_name.module_name"
module Log = (val Logs.src_log log_src : Logs.LOG)
```

**Good:**
```ocaml
Log.info (fun m ->
    m "Received event: %s" event_type
      ~tags:(Logs.Tag.add "channel_id" channel_id Logs.Tag.empty))
```


**Log Levels**: Use the following log levels appropriately:

- `Log.app`: For messages that should always be shown to the user (e.g., startup messages).

- `Log.err`: For errors that have been handled but are critical enough to report.

- `Log.warn`: For potential issues that do not prevent the current operation from completing.

- `Log.info`: For informational messages about the application's state.

- `Log.debug`: For detailed, verbose messages useful for debugging.

**Structured Logging**: Use tags to add structured context to log messages. This is especially useful for machine-readable logs.

## Testing

## Core Testing Philosophy

1. **Unit Tests First**: Prioritize unit tests for individual modules and functions.

2. **1:1 Test Coverage**: Every module in `lib/` should have a corresponding test module in `test/`.

### [E600] Test Module Convention

Test executables (test.ml) should use test suites exported by test modules (test_*.ml) rather than defining their own test lists. This promotes modularity and ensures test modules are properly integrated.

### [E605] Missing Test File

Each library module should have a corresponding test file to ensure proper testing coverage. Create test files following the naming convention test_<module>.ml

3. **Test Organization**: Test files should export a `suite` value.

### [E610] Test Without Library

Every test module should have a corresponding library module. This ensures that tests are testing actual library functionality rather than testing code that doesn't exist in the library.

4. **Test Inclusion**: All test suites must be included in the main test runner.

### [E615] Test Suite Not Included

All test modules should be included in the main test runner (test.ml). Add the missing test suite to ensure all tests are run.

5. **Clear Test Names**: Test names should describe what they test, not how.

6. **Isolated Tests**: Each test should be independent and not rely on external state.

## Test Structure

**`test/test.ml`**: A main test runner that aggregates test suites from individual `test_*.ml` files.

**`test/test_*.ml`**: Each `test_*.ml` file contains the tests for a specific module.

**`test/dune`**: Defines the test executable.

**Individual Test Files**: Each `test_*.ml` file should export a `suite` value of type `(string * Alcotest.test_case list) list`.

**Test Naming Convention**:

- Test suite names should be lowercase, single words (e.g., `"users"`, `"commands"`)

- Test case names should be lowercase with underscores, concise but descriptive (e.g., `"list"`, `"create"`, `"parse_error"`)

## Writing Good Tests

**Function Coverage**: Test all public functions exposed in `.mli` files, including success, error, and edge cases.

**Test Data**: Use helper functions to create test data.

**Property-Based Testing**: For complex logic, consider property-based testing with QCheck.

## End-to-End Testing with Cram

Cram tests are essential for verifying the behavior of the final executable.

**Use Cram Directories**: Every Cram test should be a directory ending in `.t` (e.g., `my_feature.t/`).

**Create Actual Test Files**: Avoid embedding code within the `run.t` script using `cat > file << EOF`. Create real source files within the test directory.

## Running Tests

```ocaml
# Run all tests
dune test

# Run tests and watch for changes
dune test -w

# Run tests with coverage
dune test --instrument-with bisect_ppx
bisect-ppx-report summary
```

## Commit Messages

We follow a structured format for commit messages to ensure they are clear, informative, and easy to read. A good commit message provides context for why a change was made.

## Format

A commit message consists of a short, imperative title followed by a more detailed body.

**Title**: A single, concise line summarizing the change.

- Keep it under 50 characters.

- Use the imperative mood (e.g., "Add feature" not "Added feature")

- Do not end the title with a period.

**Body**: A detailed explanation of the change, separated from the title by a blank line.

- Wrap the body at 72 characters.

- The body should be structured into paragraphs that implicitly answer three questions:

  1. **What** does this change do?

  2. **Why** was this change necessary?

  3. **How** was this change implemented?

## Example

```ocaml
feat(parser): Add support for parsing logical operators

This change introduces the capability to parse logical `AND` and `OR`
operators in the expression language. It extends the lexer to
recognize `&&` and `||` and updates the parser with new rules for
logical expressions.

The expression language previously lacked support for combining
conditions, which was a significant limitation for writing complex
business rules. This feature was requested by users to allow for more
flexible and powerful queries.

The implementation involved extending the lexer's token set with `AND`
and `OR` tokens and updating the parser's precedence rules. New AST
nodes for `LogicalAnd` and `LogicalOr` were added, and the evaluator
was updated to handle them.
```

## AI Assistants

AI assistants may be used to help write code, but the final commit must be authored by a human developer. Do not use `Co-authored-by:` trailers for AI assistants.
